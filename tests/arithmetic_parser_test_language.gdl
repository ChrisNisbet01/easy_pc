// GDL definition for the arithmetic_parser example application.
// This language definition describes the syntax of arithmetic expressions,
// including numbers, identifiers, operators, function calls, and parenthesized expressions.

// Basic Terminals
Double = double;
Number = lexeme(Double) @AST_ACTION_CREATE_NUMBER_FROM_CONTENT;
Identifier = lexeme((alpha | underscore) (alpha | digit | underscore)*) @AST_ACTION_CREATE_IDENTIFIER;

// Operators
AddOp = lexeme('+');
SubOp = lexeme('-');
MulOp = lexeme('*');
DivOp = lexeme('/');

// Structural Tokens
LParen = lexeme('(');
RParen = lexeme(')');
Comma = lexeme(',');
EOI = eoi; // End of Input

// Combined Operators
AddSubOp = AddOp | SubOp @AST_ACTION_CREATE_OPERATOR_FROM_CHAR;
MulDivOp = MulOp | DivOp @AST_ACTION_CREATE_OPERATOR_FROM_CHAR;

// Rule for Function Arguments: supports zero or more arguments
// NonEmptyFunctionArgs parses a comma-delimited list of one or more expressions.
NonEmptyFunctionArgs = delimited(Expression, Comma);
// FunctionArgs makes the entire NonEmptyFunctionArgs optional, allowing func() calls.
FunctionArgs = NonEmptyFunctionArgs?;

// Rules
FunctionCall = Identifier LParen FunctionArgs RParen @AST_ACTION_CREATE_FUNCTION_CALL;

// Primary expressions: numbers, identifiers (constants/variables), function calls, parenthesized expressions
// Note: 'LParen Expression RParen' directly handles parenthesized expressions.
Primary = Number
        | Identifier
        | FunctionCall
        | LParen Expression RParen
        ;

// Term and Expression define the order of operations using chainl1 for left-associative parsing.
// Term handles multiplication and division.
Term = chainl1(Primary, MulDivOp) @AST_ACTION_BUILD_BINARY_EXPRESSION;
// Expression handles addition and subtraction.
Expression = chainl1(Term, AddSubOp) @AST_ACTION_BUILD_BINARY_EXPRESSION;

// The top-level rule for an arithmetic program: an expression followed by End Of Input.
Program = Expression EOI @AST_ACTION_ASSIGN_ROOT;
